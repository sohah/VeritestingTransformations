node main(
  a : int;
  b : int;
  c : int;
  threshold : int;
  out : bool
) returns (
  p1 : bool
);
let
  --%MAIN;
  p1 = (true -> (out => ((((((a > 2) and (b < (a + 40))) or ((b > 10) and (c > (b + 10)))) or ((a > 0) and (c > 0))) and (threshold < repair( (c - -38) , discover_expr1(a, b, c) ) )) and (threshold > repair( ((b + c) + -20) , discover_expr2(a, b, c) ) ))));

  --%PROPERTY p1;

tel;
node discover_expr1(
  in1 : int;
  in2 : int;
  in3 : int[  hole1 : inthole;
  hole2 : inthole;
  hole3 : inthole]
) returns (
  out : int
);
let
  out = (if (hole1 = 0) then (if (hole2 = 0) then (in1 + hole3) else (if (hole2 = 1) then (in2 + hole3) else (if (hole2 = 2) then (in3 + hole3) else (if (hole2 = 3) then ((in1 + in2) + hole3) else (if (hole2 = 4) then ((in2 + in3) + hole3) else (((in1 + in2) + in3) + hole3)))))) else (if (hole2 = 0) then (in1 - hole3) else (if (hole2 = 1) then (in2 - hole3) else (if (hole2 = 2) then (in3 - hole3) else (if (hole2 = 3) then ((in1 + in2) - hole3) else (if (hole2 = 4) then ((in2 + in3) - hole3) else (((in1 + in2) + in3) - hole3)))))));

tel;

node discover_expr2(
  in1 : int;
  in2 : int;
  in3 : int[  hole4 : inthole;
  hole5 : inthole;
  hole6 : inthole]
) returns (
  out : int
);
let
  out = (if (hole4 = 0) then (if (hole5 = 0) then (in1 + hole6) else (if (hole5 = 1) then (in2 + hole6) else (if (hole5 = 2) then (in3 + hole6) else (if (hole5 = 3) then ((in1 + in2) + hole6) else (if (hole5 = 4) then ((in2 + in3) + hole6) else (((in1 + in2) + in3) + hole6)))))) else (if (hole5 = 0) then (in1 - hole6) else (if (hole5 = 1) then (in2 - hole6) else (if (hole5 = 2) then (in3 - hole6) else (if (hole5 = 3) then ((in1 + in2) - hole6) else (if (hole5 = 4) then ((in2 + in3) - hole6) else (((in1 + in2) + in3) - hole6)))))));

tel;
