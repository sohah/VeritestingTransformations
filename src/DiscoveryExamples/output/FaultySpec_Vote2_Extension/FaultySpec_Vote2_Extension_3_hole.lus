node T_node(
  a : int;
  b : int;
  c : int;
  threshold : int;
  out : bool;
  hole4 : int;
  hole5 : int;
  hole6 : int;
  hole1 : int;
  hole2 : int;
  hole3 : int
) returns (
  p1 : bool
);
let
  p1 = (true -> (out => ((((((a > 2) and (b < (a + 40))) or ((b > 10) and (c > (b + 10)))) or ((a > 0) and (c > 0))) and (threshold < discover_expr1(a, b, c, hole1, hole2, hole3))) and (threshold > discover_expr2(a, b, c, hole4, hole5, hole6)))));

tel;

node discover_expr1(
  in1 : int;
  in2 : int;
  in3 : int;
  hole1 : int;
  hole2 : int;
  hole3 : int
) returns (
  out : int
);
let
  out = (if (hole1 = 0) then (if (hole2 = 0) then (in1 + hole3) else (if (hole2 = 1) then (in2 + hole3) else (if (hole2 = 2) then (in3 + hole3) else (if (hole2 = 3) then ((in1 + in2) + hole3) else (if (hole2 = 4) then ((in2 + in3) + hole3) else (((in1 + in2) + in3) + hole3)))))) else (if (hole2 = 0) then (in1 - hole3) else (if (hole2 = 1) then (in2 - hole3) else (if (hole2 = 2) then (in3 - hole3) else (if (hole2 = 3) then ((in1 + in2) - hole3) else (if (hole2 = 4) then ((in2 + in3) - hole3) else (((in1 + in2) + in3) - hole3)))))));

tel;

node discover_expr2(
  in1 : int;
  in2 : int;
  in3 : int;
  hole4 : int;
  hole5 : int;
  hole6 : int
) returns (
  out : int
);
let
  out = (if (hole4 = 0) then (if (hole5 = 0) then (in1 + hole6) else (if (hole5 = 1) then (in2 + hole6) else (if (hole5 = 2) then (in3 + hole6) else (if (hole5 = 3) then ((in1 + in2) + hole6) else (if (hole5 = 4) then ((in2 + in3) + hole6) else (((in1 + in2) + in3) + hole6)))))) else (if (hole5 = 0) then (in1 - hole6) else (if (hole5 = 1) then (in2 - hole6) else (if (hole5 = 2) then (in3 - hole6) else (if (hole5 = 3) then ((in1 + in2) - hole6) else (if (hole5 = 4) then ((in2 + in3) - hole6) else (((in1 + in2) + in3) - hole6)))))));

tel;

node H_discovery(
  in : bool
) returns (
  out : bool
);
let
  out = (in -> (in and (pre out)));

tel;

node Check_spec(
  a : int;
  b : int;
  c : int;
  threshold : int;
  out : bool;
  hole4 : int;
  hole5 : int;
  hole6 : int;
  hole1 : int;
  hole2 : int;
  hole3 : int;
  k : int
) returns (
  p1 : bool
);
var
  step : int;
  stepOK : bool;
let
  step = (0 -> (1 + (pre step)));

  stepOK = (if (step <= k) then T_node(a, b, c, threshold, out, hole4, hole5, hole6, hole1, hole2, hole3) else true);

  p1 = ((step >= k) and H_discovery(stepOK));

tel;

node main(
  hole4 : int;
  hole5 : int;
  hole6 : int;
  hole1 : int;
  hole2 : int;
  hole3 : int
) returns (
  fail : bool
);
var
  ok_0 : bool;
  ok_1 : bool;
  ok_2 : bool;
  ok_3 : bool;
  a0 : int;
  b0 : int;
  c0 : int;
  threshold0 : int;
  out_00 : bool;
  a1 : int;
  b1 : int;
  c1 : int;
  threshold1 : int;
  out_01 : bool;
  a2 : int;
  b2 : int;
  c2 : int;
  threshold2 : int;
  out_02 : bool;
  a3 : int;
  b3 : int;
  c3 : int;
  threshold3 : int;
  out_03 : bool;
let
  --%MAIN;
  a0 = (2 -> (pre 1));

  b0 = (42 -> (pre 41));

  c0 = (53 -> (pre 14));

  threshold0 = (91 -> (pre 51));

  out_00 = (false -> (pre true));

  a1 = (2 -> (pre 1));

  b1 = (42 -> (pre 41));

  c1 = (53 -> (pre 13));

  threshold1 = (91 -> (pre 51));

  out_01 = (false -> (pre true));

  a2 = (2 -> (pre 62));

  b2 = (42 -> (pre 11));

  c2 = (53 -> (pre 0));

  threshold2 = (91 -> (pre 7));

  out_02 = (false -> (pre true));

  a3 = (2 -> (pre 3));

  b3 = (42 -> (pre 11));

  c3 = (53 -> (pre -96));

  threshold3 = (91 -> (pre 23));

  out_03 = (false -> (pre true));

  ok_0 = Check_spec(a0, b0, c0, threshold0, out_00, hole4, hole5, hole6, hole1, hole2, hole3, 1);

  ok_1 = Check_spec(a1, b1, c1, threshold1, out_01, hole4, hole5, hole6, hole1, hole2, hole3, 1);

  ok_2 = Check_spec(a2, b2, c2, threshold2, out_02, hole4, hole5, hole6, hole1, hole2, hole3, 1);

  ok_3 = Check_spec(a3, b3, c3, threshold3, out_03, hole4, hole5, hole6, hole1, hole2, hole3, 1);

  fail = (not (((ok_0 and ok_1) and ok_2) and ok_3));

  assert (true -> (hole4 = (pre hole4)));

  assert (true -> (hole5 = (pre hole5)));

  assert (true -> (hole6 = (pre hole6)));

  assert (true -> (hole1 = (pre hole1)));

  assert (true -> (hole2 = (pre hole2)));

  assert (true -> (hole3 = (pre hole3)));

  --%PROPERTY fail;

tel;
