repair node discover_expr1(in1:int; in2:int; in3:int)[hole1:inthole; hole2:inthole; hole3: inthole] returns
(out:int);

let
	out = if(hole1 = 0) -- indicates the operation to be taken
	      then if(hole2 = 0) --indicates which param to add together plus the constant
	           then (in1 + hole3)
	           else if(hole2 = 1)
	                then (in2 + hole3)
	                else if(hole2 = 2)
                         then (in3 + hole3)
                         else if(hole2 = 3)
                              then (in1 + in2 + hole3)
                              else if(hole2 = 4)
                                   then (in2 + in3 + hole3)
                                   else (in1 + in2 + in3 + hole3)
          else if(hole2 = 0) --indicates which param to add together plus the constant
	           then (in1 - hole3)
	           else if(hole2 = 1)
	                then (in2 - hole3)
	                else if(hole2 = 2)
                         then (in3 - hole3)
                         else if(hole2 = 3)
                              then (in1 + in2 - hole3)
                              else if(hole2 = 4)
                                   then (in2 + in3 - hole3)
                                   else (in1 + in2 + in3 - hole3);

tel;



repair node discover_expr2(in1:int; in2:int; in3:int)[hole4:inthole; hole5:inthole; hole6: inthole] returns
(out:int);

let
	out = if(hole4 = 0) -- indicates the operation to be taken
	      then if(hole5 = 0) --indicates which param to add together plus the constant
	           then (in1 + hole6)
	           else if(hole5 = 1)
	                then (in2 + hole6)
	                else if(hole5 = 2)
                         then (in3 + hole6)
                         else if(hole5 = 3)
                              then (in1 + in2 + hole6)
                              else if(hole5 = 4)
                                   then (in2 + in3 + hole6)
                                   else (in1 + in2 + in3 + hole6)
	      else if(hole5 = 0) --indicates which param to add together plus the constant
	           then (in1 - hole6)
	           else if(hole5 = 1)
	                then (in2 - hole6)
	                else if(hole5 = 2)
                         then (in3 - hole6)
                         else if(hole5 = 3)
                              then (in1 + in2 - hole6)
                              else if(hole5 = 4)
                                   then (in2 + in3 - hole6)
                                   else (in1 + in2 + in3 - hole6);

tel;



node main(a: int; b:int; c:int; threshold :int; out: bool) returns (p1: bool);

let

    p1 = true -> out => (((a > 2) and b < (a + 40)) or ((b > 10) and (c > (b + 10))) or ((a > 0) and (c > 0))) and
    (threshold < repair(((a + c) + 10), discover_expr1(a,b,c))) and
                                        (threshold > (repair(c, discover_expr2(a,b,c))));

  --%PROPERTY p1;

tel;
